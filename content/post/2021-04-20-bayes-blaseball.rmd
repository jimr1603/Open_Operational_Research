---
title: Bayesian Blaseball
author: James Riley
date: '`r Sys.Date()`'
slug: bayesian-blaseball
categories: 
 - R
tags:
  - Bayesian Statistics
  - Linear Regression
  - Probability Theory
  - Blaseball
  - SIBR
type: post
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	collapse = TRUE
)

library(tidyverse)


theme_set(ggthemes::theme_few())
```

# Background

In Blaseball, the fans are given some coins from the Blaseball gods so that we can bet on games, buy Concessions, and buy votes to give our favourite players Performance Enhancing Demons. Yes, buy votes, because wealth is a form of speech. 

## Blaseball Betting

As a team is more favoured to win, the payout for a winning bet goes down. This has been plucked from the site JavaScript:

```
(function (e, A) {
                return 0.5 === e
                  ? Math.round(2 * A)
                  : e < 0.5
                  ? Math.round(
                      A * (2 + 0.0015 * Math.pow(100 * (0.5 - e), 2.2))
                    )
                  : Math.round(
                      A *
                        (3.206 / (1 + Math.pow(0.443 * (e - 0.5), 0.95)) -
                          1.206)
                    );
              })(I(), v)

```

I'm going to turn this into R as follows:

```{r}
payout = function(odds, stake, round=FALSE){
  
  #validate inputs
  assertthat::assert_that(all(between(odds, 0, 1)))
  assertthat::assert_that(all(stake > 0))
  assertthat::are_equal(length(odds), length(stake))
  assertthat::is.flag(round)
  # Pad flag
  round = rep(round, length(odds))
  
  # Translation of the JS
  pay = case_when(
    odds  < 0.5 ~  stake * (2 + 0.0015 * (100 * (0.5 - odds))^2.2),
    odds == 0.5 ~ 2 * stake,
    odds  > 0.5 ~ stake *(3.206 / (1 + (0.443 * (odds - 0.5))^0.95) - 1.206)
  )
  
  # Making rounding optional
  if_else(round, round(pay), pay)
}

```


I've disabled rounding by default to make the function continuous rather than stepwise, and so it scales directly with stake. 

We can visualise this payout function:

```{r}
tibble(odds = seq(0, 1, length.out = 1000)) %>% 
  mutate(payout = payout(odds, 1)) %>% 
  ggplot(aes(x=odds,y=payout)) + 
    geom_line() + 
    expand_limits(y=0) +
    scale_x_continuous(labels=scales::percent)
```

If the odds were reliable, the Expected Payout would appear:

```{r}
tibble(odds = seq(0, 1, length.out = 1000)) %>% 
  mutate(expected_payout = odds*payout(odds, 1)) %>% 
  ggplot(aes(x=odds,y=expected_payout)) + 
    geom_line() + 
    expand_limits(y=0) +
    scale_x_continuous(labels=scales::percent) + 
    geom_hline(yintercept = 1)
```

If the odds were good, we'd max bet on the favourite always - the payout for any odds > 50% is > 1. 

# Enter Datamancy

It doesn't take long max betting on the favourite to see that the favourite wins more often than stated. SIBR have been archiving pretty much the entire data stream for a few Seasons now. 


SIBR is well-aware that the stated odds in Blasebal1 are wrong. If the game says someone is 55% likely to win they win more than 55% of the time.

SIBR rejigged their APIs, so I need to completely redesign my blaseballData library. They've made the data available as csv as well as json so I might remove the httr/json library calls and just use readr.

This is also reminding me to use pins for caching data, especially since blogdown/RStudio now loves running this whole document every time I save. 

```{r}

pins::pin("https://csv.sibr.dev/chronicler/v1/games", name="blaseball_games")

games = pins::pin_get("blaseball_games") %>% 
  read_csv()

```

& clean the data:

```{r}
games = games %>% 
  filter(`data/homeOdds`>0, `data/awayOdds`>0) %>% # Some old data does not have odds.
  rename(homeScore = `data/homeScore`, awayScore = `data/awayScore`) %>% 
  rename(homeOdds = `data/homeOdds`, awayOdds = `data/awayOdds`) %>% 
  select(homeOdds, awayOdds, homeScore, awayScore) %>% 
  filter(homeScore != awayScore) %>% # Games in progress have score=0 in this table
  mutate(homeWin = homeScore > awayScore) 

```

The site gives the odds to 0 decimal places so I'm going to be rounding the decimal odds from the feed to make N bigger.

& visualise the data:

```{r}
games %>% 
  mutate(homeOdds = round(homeOdds, 2)) %>% 
  group_by(homeOdds) %>% 
  summarise(win_pc = mean(homeWin), n=n()) %>% 
  
  ggplot(aes(x=homeOdds, y=win_pc, colour=n)) + geom_point() +
    scale_x_continuous(labels=scales::percent) + 
    scale_y_continuous(labels=scales::percent) + 
    expand_limits(x=c(0,1), y=c(0,1)) +
    scale_colour_viridis_c()

```

We're looking at the ratio of actual wins:stated odds, and it's easier to do this vertically rather than diagonally:

```{r}
games %>% 
  mutate(homeOdds = round(homeOdds, 2)) %>% 
  group_by(homeOdds) %>% 
  summarise(win_pc = mean(homeWin), n=n()) %>% 

  mutate(ratio = win_pc/homeOdds) %>% 
  ggplot(aes(x=homeOdds, y=ratio, colour=n)) + 
    geom_point() +
    scale_x_continuous(labels=scales::percent) + 
    scale_y_continuous(labels=scales::percent) + 
    expand_limits(x=c(0,1), y=c(0,1)) +
    scale_colour_viridis_c() +
    geom_hline(yintercept = 1)

```

While I'm here, the distribution of home odds looks funky:

```{r}
games %>% 
  ggplot(aes(x=homeOdds)) +
    geom_histogram(binwidth = 0.01) +
    scale_x_continuous(labels=scales::percent) + 
    expand_limits(x=c(0,1))

```

If the site was nudging the forecast winning team's odds up, then we would expect to see a bimodal distribution of odds like that. Otherwise, we'd expect a mode of ~50%, depending on how big the home team advantage is.

I've picked up [Bayesian Statistics the Fun Way](https://nostarch.com/learnbayes) in my travels. It mostly focuses on a simple case of Bayesian Reasoning - setting a beta distribution for your prior belief, and updating it with observed "successes/failures". 

Going into this I've heard that the stated odds are pretty 
