---
title: Scrabble numbers
author: James Riley
date: '2018-11-04'
slug: scrabble-numbers
categories: R
tags:
  - recreational mathematics
  - combinatorics
  - self-reference
  - brute-force
---



<div id="section" class="section level2">
<h2></h2>
<p>I was reading one of <a href="link%20to...">Ian Stewart’s</a> books of popular maths, and I found a potentially incomplete solutuion to a puzzle.</p>
<p>Given the (English) Scrable tileset, do any numbers give their own score?</p>
<p>“One” certainly doesn’t, since “O”,“N”,“E”each score 1 point, and <span class="math inline">\(3 \neq 1\)</span>.</p>
<p>For various reasons, you can see that you don’t need to test every number:</p>
<ul>
<li>Scrabble scores are non-negative integers.</li>
<li>Score increases as wordlength increases. The length of the name of a number increases approximately by powers of ten. (Or logrithmically.)</li>
</ul>
<p>So “zero”, “one”, score more points than their number, while “one thousand” definitely scores less than itself. (And there’s no word seperator in Scrabble. Anyway “thousand” definitely scores less than 1000 points.) Somewhere in the middle we might get some wins?</p>
</div>
<div id="code" class="section level2">
<h2>Code</h2>
<p>We just need a function that turns a number into a word and into a scrabble score.</p>
<pre class="r"><code>scores &lt;- tibble(
  letters = letters,
  score = c(
    1, 3, 3,
    2, 1, 4,
    2, 4, 1,
    8, 5, 1,
    3, 1, 1,
    3, 10, 1,
    1, 1, 1,
    4, 4, 8,
    4, 10
  )
)

convert_word_to_score &lt;- function(word) {
  suppressMessages(str_to_lower(word) %&gt;%
    str_extract_all(&quot;[a-z]&quot;) %&gt;%
    unlist() %&gt;%
    tibble(letters = .) %&gt;%
    left_join(scores) %&gt;%
    pull(score) %&gt;%
    sum())
}</code></pre>
<p>Giving it a try:</p>
<pre class="r"><code>convert_word_to_score(&quot;one&quot;)
## [1] 3</code></pre>
<p>I’ve grabbed names for numbers off <a href="https://en.wikipedia.org/wiki/List_of_numbers">Wiki</a>, so let’s make a table. (Copy paste is way easier in this case than messing around with scrapes or wiki API.)</p>
<pre class="r"><code>base_scores &lt;- tribble(
  ~number, ~name,
  0, &quot;Zero&quot;,
  1, &quot;One&quot;,
  2, &quot;Two&quot;,
  3, &quot;Three&quot;,
  4, &quot;Four&quot;,
  5, &quot;Five&quot;,
  6, &quot;Six&quot;,
  7, &quot;Seven&quot;,
  8, &quot;Eight&quot;,
  9, &quot;Nine&quot;,
  10, &quot;Ten&quot;,
  11, &quot;Eleven&quot;,
  12, &quot;Twelve&quot;,
  13, &quot;Thirteen&quot;,
  14, &quot;Fourteen&quot;,
  15, &quot;Fifteen&quot;,
  16, &quot;Sixteen&quot;,
  17, &quot;Seventeen&quot;,
  18, &quot;Eighteen&quot;,
  19, &quot;Nineteen&quot;,
  20, &quot;Twenty&quot;
) %&gt;%
  rowwise() %&gt;%
  mutate(score = convert_word_to_score(name))

filter(base_scores, number == score)
## Source: local data frame [1 x 3]
## Groups: &lt;by row&gt;
## 
## # A tibble: 1 x 3
##   number name   score
##    &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
## 1     12 Twelve    12</code></pre>
<p>Fortunately, my results match Prof. Stewart’s - “Twelve” scores 12 points.</p>
<p>(Let’s do a few plots…</p>
<pre class="r"><code>base_scores %&gt;%
  ggplot(aes(x = number, y = score)) + geom_point() + geom_line(aes(x = 0:20, y = 0:20)) + theme + ggtitle(&quot;Twelve is the only number with its own Scrabble score&quot;, subtitle = &quot;Line y=x added&quot;)</code></pre>
<p><img src="/posts/2018-11-04-scrabble-numbers_files/figure-html/unnamed-chunk-4-1.png" width="672" />
And:</p>
<pre class="r"><code>base_scores %&gt;%
  filter(number &gt; 0) %&gt;% # Whoops, don&#39;t divide by zero.
  mutate(relative_score = score / number) %&gt;%
  ggplot(aes(x = number, y = relative_score)) + geom_point() + theme + geom_hline(yintercept = 1) + labs(
    title = &quot;Small numbers score greater than themselves\n
    but large numbers smaller.&quot;,
    y = &quot;Score/number&quot;
  )</code></pre>
<p><img src="/posts/2018-11-04-scrabble-numbers_files/figure-html/unnamed-chunk-5-1.png" width="672" />
)</p>
<p>I attack this puzzle from two additional angles:</p>
<ol style="list-style-type: decimal">
<li>Numbers have more than one name in English.</li>
<li>There are many ways to modify the base score in Scrabble. (blank tile, letter multipliers, word multipliers…)</li>
</ol>
</div>
<div id="additional-names" class="section level1">
<h1>Additional names</h1>
<p>“Twelve” wins, but “Dozen” scores 15, and <span class="math inline">\(15 \neq 12\)</span>. This could push us into another couple of winning words.</p>
<pre class="r"><code>
alias_scores &lt;- read_csv(here::here(&quot;public&quot;, &quot;data&quot;, &quot;Wiki&quot;, &quot;names_of_numbers.csv&quot;)) %&gt;%
  separate(3, as.character(1:100), &quot;,&quot;) %&gt;%
  gather(&quot;key&quot;, &quot;name&quot;, -Number) %&gt;%
  select(-key) %&gt;%
  drop_na() %&gt;%
  mutate(name = str_extract(name, &quot;[a-zA-Z \\-]+&quot;)) %&gt;% # Too many footnotes and references to countries that need dropping
  drop_na() %&gt;%
  rowwise() %&gt;%
  mutate(score = convert_word_to_score(name))

# datatable(alias_scores, rownames = F)</code></pre>
<p>About here I realised I need to get better at tidyr, so I dropped into the manual. There might be a better way with purrr, but I liked turning this into tidy data, particularly because I can chuck it at ggplot again.</p>
<p>Anyway, did I get more solutions?</p>
<pre class="r"><code>
alias_scores %&gt;%
  filter(Number==score) %&gt;%
  knitr::kable()</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">Number</th>
<th align="left">name</th>
<th align="right">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">12</td>
<td align="left">Twelve</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="left">octad</td>
<td align="right">8</td>
</tr>
<tr class="odd">
<td align="right">10</td>
<td align="left">decade</td>
<td align="right">10</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="left">set</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="right">6</td>
<td align="left">sestet</td>
<td align="right">6</td>
</tr>
<tr class="even">
<td align="right">Sweet, I</td>
<td align="left">explanded</td>
<td align="right">the solution space 5x!</td>
</tr>
</tbody>
</table>
<p>Let’s have another look at score relative to number:</p>
<pre class="r"><code>alias_scores %&gt;%
  filter(Number &gt; 0) %&gt;%
  mutate(relative_score = score / Number) %&gt;%
  ggplot(aes(x = Number, y = relative_score)) + geom_point() + theme + geom_hline(yintercept = 1) + labs(
    title = &quot;There are more winning numbers if we take other common name&quot;,
    y = &quot;Score/Number&quot;
  )</code></pre>
<p><img src="/posts/2018-11-04-scrabble-numbers_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
</div>
<div id="score-modifications" class="section level1">
<h1>Score modifications</h1>
<div id="part-1-the-blank-tile" class="section level2">
<h2>Part 1: the blank tile</h2>
<p>Quite a few of the early numbers score more than their value. We might get some of these to turn into winners if we replace some of their letters with the blank tile. This is allowed to substitute any letter, but gives no score.</p>
<p>Right now I’m not going to worry about the actual number of blanks in a Scrabble set, and allow myself as many blank tiles as I want. (Which was implicit in the earlier stuff with the actual letters.)</p>
<p>I need to modify the function that makes a score so it can accept modifiers. In this case, the zero multiplier on a given tile:</p>
<pre class="r"><code>
word_to_score &lt;- function(word, modifier = 1) {

  # I am terrible at writing vectorised functions.

  if (class(modifier) == &quot;list&quot;) modifier &lt;- unlist(modifier)

  suppressMessages(str_to_lower(word) %&gt;%
    str_extract_all(&quot;[a-z]&quot;) %&gt;%
    unlist() %&gt;%
    tibble(letters = ., modifier = modifier) %&gt;%
    left_join(scores) %&gt;%
    summarise(score = sum(score * modifier)) %&gt;%
    pull())
}</code></pre>
<p>The <em>hiliarious</em> thing is that for a word of length <span class="math inline">\(n\)</span>, I have to work out <span class="math inline">\(2^n\)</span> ways you can fill it in with blank tiles. At least I know this will only decrease the score, so I can start with the ones who overscored.</p>
<p>I’m not sure about generating all the binary codes with the word’s length, so I recursed. For a small time save, I generate them all now.</p>
<pre class="r"><code>binary &lt;- list(crossing(0:1))

for (i in 2:12) {
  binary &lt;- append(
    binary,
    list(
      crossing(binary[[i - 1]], 0:1)
    )
  )
}

binary &lt;- map(binary, transpose) %&gt;%
  flatten() %&gt;%
  tibble(sequence = .) %&gt;%
  rowwise() %&gt;%
  mutate(length = length(sequence)) %&gt;%
  ungroup()</code></pre>
<p>Now I can slap these sequences on the words that overscored.</p>
<pre class="r"><code>blank_scores &lt;- alias_scores %&gt;%
  mutate(name = name %&gt;%
    str_to_lower() %&gt;%
    str_remove_all(&quot;\\W&quot;)) %&gt;%
  filter(score &gt; Number) %&gt;%
  mutate(length = str_length(name)) %&gt;%
  left_join(binary) %&gt;%
  rowwise() %&gt;%
  mutate(score_with_blanks = word_to_score(name, sequence))


blank_scores %&gt;%
  select(Number, name, score_with_blanks) %&gt;%
  filter(Number == score_with_blanks) %&gt;%
  unique() %&gt;%
  ungroup() %&gt;%
  dplyr::arrange(Number)
## # A tibble: 103 x 3
##    Number name     score_with_blanks
##     &lt;int&gt; &lt;chr&gt;                &lt;dbl&gt;
##  1      0 zero                     0
##  2      0 aught                    0
##  3      0 cipher                   0
##  4      0 cypher                   0
##  5      0 donut                    0
##  6      0 dot                      0
##  7      0 duck                     0
##  8      0 gooseegg                 0
##  9      0 love                     0
## 10      0 nada                     0
## # ... with 93 more rows</code></pre>
<p>Most of the previous losers have at least one winner. 0 and 1 are easy to see why - all blanks gives you 0 points, and most names for 1 have a letter that only has one point.</p>
<p>I’ll just add a function to show where the blank tile(s) are appearing, and I’ll do that table again:</p>
<pre class="r"><code>blankify &lt;- function(word, mask) {
  word %&gt;%
    str_extract_all(&quot;[a-z]&quot;) %&gt;%
    unlist() %&gt;%
    replace(which(mask == 0), &quot;_&quot;) %&gt;%
    str_flatten()
}


blank_scores %&gt;%
  select(Number, sequence, name, score_with_blanks) %&gt;%
  filter(Number == score_with_blanks) %&gt;%
  mutate(name_with_blanks = blankify(name, sequence)) %&gt;%
  select(name, name_with_blanks,Number) %&gt;%
  ungroup() %&gt;%
  dplyr::arrange(Number)
## # A tibble: 1,245 x 3
##    name     name_with_blanks Number
##    &lt;chr&gt;    &lt;chr&gt;             &lt;int&gt;
##  1 zero     ____                  0
##  2 aught    _____                 0
##  3 cipher   ______                0
##  4 cypher   ______                0
##  5 donut    _____                 0
##  6 dot      ___                   0
##  7 duck     ____                  0
##  8 gooseegg ________              0
##  9 love     ____                  0
## 10 nada     ____                  0
## # ... with 1,235 more rows</code></pre>
</div>
<div id="moving-on" class="section level2">
<h2>Moving on</h2>
<p>This suggests a method that can be extended for dealing with double/triple letters, and even triple words, but I feel this post is long enough for now.</p>
</div>
</div>
